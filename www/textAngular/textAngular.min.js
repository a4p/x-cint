var textAngularSetup = {
    translationStrings: {
        toggleHTML: "Toggle HTML",
        insertImage: "Please enter a image URL to insert",
        insertLink: "Please enter a URL to insert",
        insertVideo: "Please enter a youtube URL to embed"
    },
    selectableElements: [ "a", "img" ],
    customDisplayRenderers: [ {
        selector: "img",
        customAttribute: "ta-insert-video",
        renderLogic: function(element) {
            var iframe = angular.element("<iframe></iframe>"), attributes = element.prop("attributes");
            angular.forEach(attributes, function(attr) {
                iframe.attr(attr.name, attr.value);
            }), iframe.attr("src", iframe.attr("ta-insert-video")), element.replaceWith(iframe);
        }
    } ],
    options: {
        toolbar: [ [ "h1", "h2", "h3", "h4", "h5", "h6", "p", "pre", "quote" ], [ "bold", "italics", "underline", "ul", "ol", "redo", "undo", "clear" ], [ "justifyLeft", "justifyCenter", "justifyRight" ], [ "html", "insertImage", "insertLink", "insertVideo" ] ],
        classes: {
            focussed: "focussed",
            toolbar: "btn-toolbar",
            toolbarGroup: "btn-group",
            toolbarButton: "btn btn-default",
            toolbarButtonActive: "active",
            disabled: "disabled",
            textEditor: "form-control",
            htmlEditor: "form-control"
        },
        setup: {
            textEditorSetup: function() {},
            htmlEditorSetup: function() {}
        },
        defaultFileDropHandler: function(file, insertAction) {
            var reader = new FileReader();
            return "image" === file.type.substring(0, 5) ? (reader.onload = function() {
                "" !== reader.result && insertAction("insertImage", reader.result, !0);
            }, reader.readAsDataURL(file), !0) : !1;
        }
    },
    registerToolsFunction: function(taRegisterTool, $window, taTranslations) {
        taRegisterTool("html", {
            buttontext: taTranslations.toggleHTML,
            action: function() {
                this.$editor().switchView();
            },
            activeState: function() {
                return this.$editor().showHtml;
            }
        });
        var _retActiveStateFunction = function(q) {
            return function() {
                return this.$editor().queryFormatBlockState(q);
            };
        }, headerAction = function() {
            return this.$editor().wrapSelection("formatBlock", "<" + this.name.toUpperCase() + ">");
        };
        angular.forEach([ "h1", "h2", "h3", "h4", "h5", "h6" ], function(h) {
            taRegisterTool(h.toLowerCase(), {
                buttontext: h.toUpperCase(),
                action: headerAction,
                activeState: _retActiveStateFunction(h.toLowerCase())
            });
        }), taRegisterTool("p", {
            buttontext: "P",
            action: function() {
                return this.$editor().wrapSelection("formatBlock", "<P>");
            },
            activeState: function() {
                return this.$editor().queryFormatBlockState("p");
            }
        }), taRegisterTool("pre", {
            buttontext: "pre",
            action: function() {
                return this.$editor().wrapSelection("formatBlock", "<PRE>");
            },
            activeState: function() {
                return this.$editor().queryFormatBlockState("pre");
            }
        }), taRegisterTool("ul", {
            iconclass: "fa fa-list-ul",
            action: function() {
                return this.$editor().wrapSelection("insertUnorderedList", null);
            },
            activeState: function() {
                return document.queryCommandState("insertUnorderedList");
            }
        }), taRegisterTool("ol", {
            iconclass: "fa fa-list-ol",
            action: function() {
                return this.$editor().wrapSelection("insertOrderedList", null);
            },
            activeState: function() {
                return document.queryCommandState("insertOrderedList");
            }
        }), taRegisterTool("quote", {
            iconclass: "fa fa-quote-right",
            action: function() {
                return this.$editor().wrapSelection("formatBlock", "<BLOCKQUOTE>");
            },
            activeState: function() {
                return this.$editor().queryFormatBlockState("blockquote");
            }
        }), taRegisterTool("undo", {
            iconclass: "fa fa-undo",
            action: function() {
                return this.$editor().wrapSelection("undo", null);
            }
        }), taRegisterTool("redo", {
            iconclass: "fa fa-repeat",
            action: function() {
                return this.$editor().wrapSelection("redo", null);
            }
        }), taRegisterTool("bold", {
            iconclass: "fa fa-bold",
            action: function() {
                return this.$editor().wrapSelection("bold", null);
            },
            activeState: function() {
                return document.queryCommandState("bold");
            },
            commandKeyCode: 98
        }), taRegisterTool("justifyLeft", {
            iconclass: "fa fa-align-left",
            action: function() {
                return this.$editor().wrapSelection("justifyLeft", null);
            },
            activeState: function(commonElement) {
                var result = !1;
                return commonElement && (result = "left" === commonElement.css("text-align") || "left" === commonElement.attr("align") || "right" !== commonElement.css("text-align") && "center" !== commonElement.css("text-align") && !document.queryCommandState("justifyRight") && !document.queryCommandState("justifyCenter")), 
                result = result || document.queryCommandState("justifyLeft");
            }
        }), taRegisterTool("justifyRight", {
            iconclass: "fa fa-align-right",
            action: function() {
                return this.$editor().wrapSelection("justifyRight", null);
            },
            activeState: function(commonElement) {
                var result = !1;
                return commonElement && (result = "right" === commonElement.css("text-align")), 
                result = result || document.queryCommandState("justifyRight");
            }
        }), taRegisterTool("justifyCenter", {
            iconclass: "fa fa-align-center",
            action: function() {
                return this.$editor().wrapSelection("justifyCenter", null);
            },
            activeState: function(commonElement) {
                var result = !1;
                return commonElement && (result = "center" === commonElement.css("text-align")), 
                result = result || document.queryCommandState("justifyCenter");
            }
        }), taRegisterTool("italics", {
            iconclass: "fa fa-italic",
            action: function() {
                return this.$editor().wrapSelection("italic", null);
            },
            activeState: function() {
                return document.queryCommandState("italic");
            },
            commandKeyCode: 105
        }), taRegisterTool("underline", {
            iconclass: "fa fa-underline",
            action: function() {
                return this.$editor().wrapSelection("underline", null);
            },
            activeState: function() {
                return document.queryCommandState("underline");
            },
            commandKeyCode: 117
        }), taRegisterTool("clear", {
            iconclass: "fa fa-ban",
            action: function(deferred, restoreSelection) {
                this.$editor().wrapSelection("removeFormat", null);
                var _ranges = [];
                if (this.$window.rangy && this.$window.rangy.getSelection && 1 === (_ranges = this.$window.rangy.getSelection().getAllRanges()).length) {
                    var possibleNodes = angular.element(_ranges[0].commonAncestorContainer), removeListElements = function(list) {
                        list = angular.element(list);
                        var prevElement = list;
                        angular.forEach(list.children(), function(liElem) {
                            var newElem = angular.element("<p></p>");
                            newElem.html(angular.element(liElem).html()), prevElement.after(newElem), prevElement = newElem;
                        }), list.remove();
                    };
                    angular.forEach(possibleNodes.find("ul"), removeListElements), angular.forEach(possibleNodes.find("ol"), removeListElements);
                    var $editor = this.$editor(), recursiveRemoveClass = function(node) {
                        node = angular.element(node), node[0] !== $editor.displayElements.text[0] && node.removeAttr("class"), 
                        angular.forEach(node.children(), recursiveRemoveClass);
                    };
                    angular.forEach(possibleNodes, recursiveRemoveClass), "li" !== possibleNodes[0].tagName.toLowerCase() && "ol" !== possibleNodes[0].tagName.toLowerCase() && "ul" !== possibleNodes[0].tagName.toLowerCase() && this.$editor().wrapSelection("formatBlock", "<p>");
                } else this.$editor().wrapSelection("formatBlock", "<p>");
                restoreSelection();
            }
        });
        var imgOnSelectAction = function(event, $element, editorScope) {
            var finishEdit = function() {
                editorScope.updateTaBindtaTextElement(), editorScope.hidePopover();
            };
            event.preventDefault(), editorScope.displayElements.popover.css("width", "375px");
            var container = editorScope.displayElements.popoverContainer;
            container.empty();
            var buttonGroup = angular.element('<div class="btn-group" style="padding-right: 6px;">'), fullButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">100% </button>');
            fullButton.on("click", function(event) {
                event.preventDefault(), $element.css({
                    width: "100%",
                    height: ""
                }), finishEdit();
            });
            var halfButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">50% </button>');
            halfButton.on("click", function(event) {
                event.preventDefault(), $element.css({
                    width: "50%",
                    height: ""
                }), finishEdit();
            });
            var quartButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">25% </button>');
            quartButton.on("click", function(event) {
                event.preventDefault(), $element.css({
                    width: "25%",
                    height: ""
                }), finishEdit();
            });
            var resetButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">Reset</button>');
            resetButton.on("click", function(event) {
                event.preventDefault(), $element.css({
                    width: "",
                    height: ""
                }), finishEdit();
            }), buttonGroup.append(fullButton), buttonGroup.append(halfButton), buttonGroup.append(quartButton), 
            buttonGroup.append(resetButton), container.append(buttonGroup), buttonGroup = angular.element('<div class="btn-group" style="padding-right: 6px;">');
            var floatLeft = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-left"></i></button>');
            floatLeft.on("click", function(event) {
                event.preventDefault(), $element.css("float", "left"), finishEdit();
            });
            var floatRight = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-right"></i></button>');
            floatRight.on("click", function(event) {
                event.preventDefault(), $element.css("float", "right"), finishEdit();
            });
            var floatNone = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-justify"></i></button>');
            floatNone.on("click", function(event) {
                event.preventDefault(), $element.css("float", ""), finishEdit();
            }), buttonGroup.append(floatLeft), buttonGroup.append(floatNone), buttonGroup.append(floatRight), 
            container.append(buttonGroup), buttonGroup = angular.element('<div class="btn-group">');
            var remove = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-trash-o"></i></button>');
            remove.on("click", function(event) {
                event.preventDefault(), $element.remove(), finishEdit();
            }), buttonGroup.append(remove), container.append(buttonGroup), editorScope.showPopover($element);
        };
        taRegisterTool("insertImage", {
            iconclass: "fa fa-picture-o",
            action: function() {
                var imageLink;
                return imageLink = $window.prompt(taTranslations.insertImage, "http://"), imageLink && "" !== imageLink && "http://" !== imageLink ? this.$editor().wrapSelection("insertImage", imageLink, !0) : void 0;
            },
            onElementSelect: {
                element: "img",
                action: imgOnSelectAction
            }
        }), taRegisterTool("insertVideo", {
            iconclass: "fa fa-youtube-play",
            action: function() {
                var urlPrompt;
                if (urlPrompt = $window.prompt(taTranslations.insertVideo, "http://"), urlPrompt && "" !== urlPrompt && "http://" !== urlPrompt) {
                    var ids = urlPrompt.match(/(\?|&)v=[^&]*/);
                    if (ids.length > 0) {
                        var urlLink = "http://www.youtube.com/embed/" + ids[0].substring(3), embed = '<img class="ta-insert-video" ta-insert-video="' + urlLink + '" contenteditable="false" src="" allowfullscreen="true" width="300" frameborder="0" height="250"/>';
                        return this.$editor().wrapSelection("insertHTML", embed, !0);
                    }
                }
            },
            onElementSelect: {
                element: "img",
                onlyWithAttrs: [ "ta-insert-video" ],
                action: imgOnSelectAction
            }
        }), taRegisterTool("insertLink", {
            iconclass: "fa fa-link",
            action: function() {
                var urlLink;
                return urlLink = $window.prompt(taTranslations.insertLink, "http://"), urlLink && "" !== urlLink && "http://" !== urlLink ? this.$editor().wrapSelection("createLink", urlLink, !0) : void 0;
            },
            activeState: function(commonElement) {
                return commonElement ? "A" === commonElement[0].tagName : !1;
            },
            onElementSelect: {
                element: "a",
                action: function(event, $element, editorScope) {
                    event.preventDefault(), editorScope.displayElements.popover.css("width", "305px");
                    var container = editorScope.displayElements.popoverContainer;
                    container.empty(), container.css("line-height", "28px");
                    var link = angular.element('<a href="' + $element.attr("href") + '" target="_blank">' + $element.attr("href") + "</a>");
                    link.css({
                        display: "inline-block",
                        "max-width": "200px",
                        overflow: "hidden",
                        "text-overflow": "ellipsis",
                        "white-space": "nowrap",
                        "vertical-align": "middle"
                    }), container.append(link);
                    var buttonGroup = angular.element('<div class="btn-group pull-right">'), reLinkButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on"><i class="fa fa-edit icon-edit"></i></button>');
                    reLinkButton.on("click", function(event) {
                        event.preventDefault();
                        var urlLink = $window.prompt(taTranslations.insertLink, $element.attr("href"));
                        "" !== urlLink && ($element.attr("href", urlLink), editorScope.updateTaBindtaTextElement()), 
                        editorScope.hidePopover();
                    }), buttonGroup.append(reLinkButton);
                    var unLinkButton = angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on"><i class="fa fa-unlink icon-unlink"></i></button>');
                    unLinkButton.on("click", function(event) {
                        event.preventDefault(), $element.replaceWith($element.contents()), editorScope.updateTaBindtaTextElement(), 
                        editorScope.hidePopover();
                    }), buttonGroup.append(unLinkButton), container.append(buttonGroup), editorScope.showPopover($element);
                }
            }
        });
    }
};

!function() {
    "Use Strict";
    function validElementString(string) {
        try {
            return 0 !== angular.element(string).length;
        } catch (any) {
            return !1;
        }
    }
    function addCSSRule(selector, rules) {
        var insertIndex = Math.max(sheet.rules.length - 1, 0);
        return sheet.insertRule ? sheet.insertRule(selector + "{" + rules + "}", insertIndex) : sheet.addRule(selector, rules, insertIndex), 
        insertIndex;
    }
    function removeCSSRule(index) {
        sheet.removeRule ? sheet.removeRule(index) : sheet.deleteRule(index);
    }
    function getByAttribute(element, attribute) {
        var resultingElements = [], childNodes = element.children();
        return childNodes.length && angular.forEach(childNodes, function(child) {
            resultingElements = resultingElements.concat(getByAttribute(angular.element(child), attribute));
        }), void 0 !== element.attr(attribute) && resultingElements.push(element), resultingElements;
    }
    function registerTextAngularTool(name, toolDefinition) {
        if (!name || "" === name || taTools.hasOwnProperty(name)) throw "textAngular Error: A unique name is required for a Tool Definition";
        if (toolDefinition.display && ("" === toolDefinition.display || !validElementString(toolDefinition.display)) || !toolDefinition.display && !toolDefinition.buttontext && !toolDefinition.iconclass) throw 'textAngular Error: Tool Definition for "' + name + '" does not have a valid display/iconclass/buttontext value';
        taTools[name] = toolDefinition;
    }
    var ie = function() {
        var undef, rv = -1, ua = window.navigator.userAgent, msie = ua.indexOf("MSIE "), trident = ua.indexOf("Trident/");
        if (msie > 0) rv = parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10); else if (trident > 0) {
            var rvNum = ua.indexOf("rv:");
            rv = parseInt(ua.substring(rvNum + 3, ua.indexOf(".", rvNum)), 10);
        }
        return rv > -1 ? rv : undef;
    }(), isTouchSupported = "ontouchstart" in window, startEvent = isTouchSupported ? "touchstart" : "mousedown", endEvent = isTouchSupported ? "touchend" : "mouseup", sheet = function() {
        var style = document.createElement("style");
        return style.appendChild(document.createTextNode("")), document.head.appendChild(style), 
        style.sheet;
    }(), dropFired = !1, textAngular = angular.module("textAngular", [ "ngSanitize" ]);
    if (void 0 === textAngularSetup) throw "textAngular Error: Setup Options are not defined, see textAngularSetup.js for example.";
    textAngular.value("taOptions", textAngularSetup.options), textAngular.value("taSelectableElements", textAngularSetup.selectableElements), 
    textAngular.value("taCustomRenderers", textAngularSetup.customDisplayRenderers);
    var taTools = {};
    textAngular.constant("taTranslations", textAngularSetup.translationStrings), textAngular.constant("taRegisterTool", registerTextAngularTool), 
    textAngular.value("taTools", taTools), textAngular.run([ "taRegisterTool", "$window", "taTranslations", function(taRegisterTool, $window, taTranslations) {
        angular.forEach(taTools, function(value, key) {
            delete taTools[key];
        }), textAngularSetup.registerToolsFunction(taRegisterTool, $window, taTranslations);
    } ]), textAngular.directive("textAngular", [ "$compile", "$timeout", "taOptions", "taSanitize", "textAngularManager", "$window", "$animate", "$log", function($compile, $timeout, taOptions, taSanitize, textAngularManager, $window, $animate, $log) {
        return {
            require: "?ngModel",
            scope: {},
            restrict: "EA",
            link: function(scope, element, attrs, ngModel) {
                var _keydown, _keyup, _keypress, _mouseup, _focusin, _focusout, _originalContents, _toolbars, _serial = Math.floor(1e16 * Math.random()), _name = attrs.name ? attrs.name : "textAngularEditor" + _serial;
                angular.extend(scope, angular.copy(taOptions), {
                    wrapSelection: function(command, opt, isSelectableElementTool) {
                        try {
                            document.execCommand(command, !1, opt);
                        } catch (e) {}
                        isSelectableElementTool && scope["reApplyOnSelectorHandlerstaTextElement" + _serial](), 
                        scope.displayElements.text[0].focus();
                    },
                    showHtml: !1
                }), attrs.taFocussedClass && (scope.classes.focussed = attrs.taFocussedClass), attrs.taTextEditorClass && (scope.classes.textEditor = attrs.taTextEditorClass), 
                attrs.taHtmlEditorClass && (scope.classes.htmlEditor = attrs.taHtmlEditorClass), 
                attrs.taTextEditorSetup && (scope.setup.textEditorSetup = scope.$parent.$eval(attrs.taTextEditorSetup)), 
                attrs.taHtmlEditorSetup && (scope.setup.htmlEditorSetup = scope.$parent.$eval(attrs.taHtmlEditorSetup)), 
                scope.fileDropHandler = attrs.taFileDrop ? scope.$parent.$eval(attrs.taFileDrop) : scope.defaultFileDropHandler, 
                _originalContents = element[0].innerHTML, element[0].innerHTML = "", scope.displayElements = {
                    forminput: angular.element("<input type='hidden' tabindex='-1' style='display: none;'>"),
                    html: angular.element("<textarea></textarea>"),
                    text: angular.element("<div></div>"),
                    popover: angular.element('<div class="popover fade bottom" style="max-width: none; width: 305px;"><div class="arrow"></div></div>'),
                    popoverContainer: angular.element('<div class="popover-content"></div>')
                }, scope.displayElements.popover.append(scope.displayElements.popoverContainer), 
                element.append(scope.displayElements.popover), scope.displayElements.popover.on(startEvent, function(e, eventData) {
                    return eventData && angular.extend(e, eventData), e.preventDefault(), !1;
                }), scope.showPopover = function(_el) {
                    scope.displayElements.popover.css("top", _el[0].offsetTop + _el[0].offsetHeight + "px"), 
                    scope.displayElements.popover.css("left", _el[0].offsetLeft + _el[0].offsetWidth / 2 - 152.5 + "px"), 
                    scope.displayElements.popover.css("display", "block"), $animate.addClass(scope.displayElements.popover, "in"), 
                    $timeout(function() {
                        var _func = function() {
                            element.off("click", _func), scope.hidePopover();
                        };
                        element.on("click", _func);
                    }, 100);
                }, scope.hidePopover = function() {
                    $animate.removeClass(scope.displayElements.popover, "in", function() {
                        scope.displayElements.popover.css("display", ""), scope.displayElements.popoverContainer.attr("style", ""), 
                        scope.displayElements.popoverContainer.attr("class", "popover-content");
                    });
                }, scope.setup.htmlEditorSetup(scope.displayElements.html), scope.setup.textEditorSetup(scope.displayElements.text), 
                scope.displayElements.html.attr({
                    id: "taHtmlElement" + _serial,
                    "ng-show": "showHtml",
                    "ta-bind": "ta-bind",
                    "ng-model": "html"
                }), scope.displayElements.text.attr({
                    id: "taTextElement" + _serial,
                    contentEditable: "true",
                    "ng-hide": "showHtml",
                    "ta-bind": "ta-bind",
                    "ng-model": "html"
                }), attrs.taDefaultWrap && scope.displayElements.text.attr("ta-default-wrap", attrs.taDefaultWrap), 
                element.append(scope.displayElements.text), element.append(scope.displayElements.html), 
                scope.displayElements.forminput.attr("name", _name), element.append(scope.displayElements.forminput), 
                attrs.tabindex && (element.removeAttr("tabindex"), scope.displayElements.text.attr("tabindex", attrs.tabindex), 
                scope.displayElements.html.attr("tabindex", attrs.tabindex)), attrs.placeholder && (scope.displayElements.text.attr("placeholder", attrs.placeholder), 
                scope.displayElements.html.attr("placeholder", attrs.placeholder)), attrs.taDisabled && (scope.displayElements.text.attr("ta-readonly", "disabled"), 
                scope.displayElements.html.attr("ta-readonly", "disabled"), scope.disabled = scope.$parent.$eval(attrs.taDisabled), 
                scope.$parent.$watch(attrs.taDisabled, function(newVal) {
                    scope.disabled = newVal, scope.disabled ? element.addClass(scope.classes.disabled) : element.removeClass(scope.classes.disabled);
                })), $compile(scope.displayElements.text)(scope), $compile(scope.displayElements.html)(scope), 
                scope.updateTaBindtaTextElement = scope["updateTaBindtaTextElement" + _serial], 
                scope.updateTaBindtaHtmlElement = scope["updateTaBindtaHtmlElement" + _serial], 
                element.addClass("ta-root"), scope.displayElements.text.addClass("ta-text ta-editor " + scope.classes.textEditor), 
                scope.displayElements.html.addClass("ta-html ta-editor " + scope.classes.textEditor), 
                scope._actionRunning = !1;
                var _savedSelection = !1;
                if (scope.startAction = function() {
                    return scope._actionRunning = !0, $window.rangy && $window.rangy.saveSelection ? (_savedSelection = $window.rangy.saveSelection(), 
                    function() {
                        _savedSelection && $window.rangy.restoreSelection(_savedSelection);
                    }) : void 0;
                }, scope.endAction = function() {
                    scope._actionRunning = !1, _savedSelection && $window.rangy.removeMarkers(_savedSelection), 
                    _savedSelection = !1, scope.updateSelectedStyles(), scope.showHtml || scope["updateTaBindtaTextElement" + _serial]();
                }, _focusin = function() {
                    element.addClass(scope.classes.focussed), _toolbars.focus();
                }, scope.displayElements.html.on("focus", _focusin), scope.displayElements.text.on("focus", _focusin), 
                _focusout = function(e) {
                    return scope._actionRunning || document.activeElement === scope.displayElements.html[0] || document.activeElement === scope.displayElements.text[0] || (element.removeClass(scope.classes.focussed), 
                    _toolbars.unfocus(), $timeout(function() {
                        element.triggerHandler("blur");
                    }, 0)), e.preventDefault(), !1;
                }, scope.displayElements.html.on("blur", _focusout), scope.displayElements.text.on("blur", _focusout), 
                scope.queryFormatBlockState = function(command) {
                    return command.toLowerCase() === document.queryCommandValue("formatBlock").toLowerCase();
                }, scope.switchView = function() {
                    scope.showHtml = !scope.showHtml, scope.showHtml ? $timeout(function() {
                        return scope.displayElements.html[0].focus();
                    }, 100) : $timeout(function() {
                        return scope.displayElements.text[0].focus();
                    }, 100);
                }, attrs.ngModel) {
                    var _firstRun = !0;
                    ngModel.$render = function() {
                        if (_firstRun) {
                            _firstRun = !1;
                            var _initialValue = scope.$parent.$eval(attrs.ngModel);
                            void 0 !== _initialValue && null !== _initialValue || !_originalContents || "" === _originalContents || ngModel.$setViewValue(_originalContents);
                        }
                        scope.displayElements.forminput.val(ngModel.$viewValue), scope._elementSelectTriggered || document.activeElement === scope.displayElements.html[0] || document.activeElement === scope.displayElements.text[0] || (scope.html = ngModel.$viewValue || "");
                    };
                } else scope.displayElements.forminput.val(_originalContents), scope.html = _originalContents;
                if (scope.$watch("html", function(newValue, oldValue) {
                    newValue !== oldValue && (attrs.ngModel && ngModel.$viewValue !== newValue && ngModel.$setViewValue(newValue), 
                    scope.displayElements.forminput.val(newValue));
                }), attrs.taTargetToolbars) _toolbars = textAngularManager.registerEditor(_name, scope, attrs.taTargetToolbars.split(",")); else {
                    var _toolbar = angular.element('<div text-angular-toolbar name="textAngularToolbar' + _serial + '">');
                    attrs.taToolbar && _toolbar.attr("ta-toolbar", attrs.taToolbar), attrs.taToolbarClass && _toolbar.attr("ta-toolbar-class", attrs.taToolbarClass), 
                    attrs.taToolbarGroupClass && _toolbar.attr("ta-toolbar-group-class", attrs.taToolbarGroupClass), 
                    attrs.taToolbarButtonClass && _toolbar.attr("ta-toolbar-button-class", attrs.taToolbarButtonClass), 
                    attrs.taToolbarActiveButtonClass && _toolbar.attr("ta-toolbar-active-button-class", attrs.taToolbarActiveButtonClass), 
                    attrs.taFocussedClass && _toolbar.attr("ta-focussed-class", attrs.taFocussedClass), 
                    element.prepend(_toolbar), $compile(_toolbar)(scope.$parent), _toolbars = textAngularManager.registerEditor(_name, scope, [ "textAngularToolbar" + _serial ]);
                }
                scope.$on("$destroy", function() {
                    textAngularManager.unregisterEditor(_name);
                }), scope.$on("ta-element-select", function(event, element) {
                    _toolbars.triggerElementSelect(event, element);
                }), scope.$on("ta-drop-event", function(event, element, dropEvent, dataTransfer) {
                    scope.displayElements.text[0].focus(), dataTransfer && dataTransfer.files && dataTransfer.files.length > 0 && (angular.forEach(dataTransfer.files, function(file) {
                        try {
                            return scope.fileDropHandler(file, scope.wrapSelection) || scope.fileDropHandler !== scope.defaultFileDropHandler && scope.defaultFileDropHandler(file, scope.wrapSelection);
                        } catch (error) {
                            $log.error(error);
                        }
                    }), dropEvent.preventDefault(), dropEvent.stopPropagation());
                }), scope._bUpdateSelectedStyles = !1, scope.updateSelectedStyles = function() {
                    var _ranges;
                    $window.rangy && $window.rangy.getSelection && 1 === (_ranges = $window.rangy.getSelection().getAllRanges()).length && _ranges[0].commonAncestorContainer.parentNode !== scope.displayElements.text[0] ? _toolbars.updateSelectedStyles(angular.element(_ranges[0].commonAncestorContainer.parentNode)) : _toolbars.updateSelectedStyles(), 
                    scope._bUpdateSelectedStyles && $timeout(scope.updateSelectedStyles, 200);
                }, _keydown = function() {
                    scope._bUpdateSelectedStyles || (scope._bUpdateSelectedStyles = !0, scope.$apply(function() {
                        scope.updateSelectedStyles();
                    }));
                }, scope.displayElements.html.on("keydown", _keydown), scope.displayElements.text.on("keydown", _keydown), 
                _keyup = function() {
                    scope._bUpdateSelectedStyles = !1;
                }, scope.displayElements.html.on("keyup", _keyup), scope.displayElements.text.on("keyup", _keyup), 
                _keypress = function(event, eventData) {
                    eventData && angular.extend(event, eventData), scope.$apply(function() {
                        return _toolbars.sendKeyCommand(event) ? (scope._bUpdateSelectedStyles || scope.updateSelectedStyles(), 
                        event.preventDefault(), !1) : void 0;
                    });
                }, scope.displayElements.html.on("keypress", _keypress), scope.displayElements.text.on("keypress", _keypress), 
                _mouseup = function() {
                    scope._bUpdateSelectedStyles = !1, scope.$apply(function() {
                        scope.updateSelectedStyles();
                    });
                }, scope.displayElements.html.on(endEvent, _mouseup), scope.displayElements.text.on(endEvent, _mouseup);
            }
        };
    } ]).directive("taBind", [ "taSanitize", "$timeout", "$window", "taFixChrome", "taSelectableElements", "taApplyCustomRenderers", function(taSanitize, $timeout, $window, taFixChrome, taSelectableElements, taApplyCustomRenderers) {
        return {
            require: "ngModel",
            scope: {},
            link: function(scope, element, attrs, ngModel) {
                var _defaultVal, _isContentEditable = void 0 !== element.attr("contenteditable") && element.attr("contenteditable"), _isInputFriendly = _isContentEditable || "textarea" === element[0].tagName.toLowerCase() || "input" === element[0].tagName.toLowerCase(), _isReadonly = !1, _focussed = !1;
                void 0 === attrs.taDefaultWrap && (attrs.taDefaultWrap = "p"), _defaultVal = "" === attrs.taDefaultWrap ? "" : void 0 === ie ? "<" + attrs.taDefaultWrap + "><br></" + attrs.taDefaultWrap + ">" : "<" + attrs.taDefaultWrap + "></" + attrs.taDefaultWrap + ">";
                var _compileHtml = function() {
                    if (_isContentEditable) return element[0].innerHTML;
                    if (_isInputFriendly) return element.val();
                    throw "textAngular Error: attempting to update non-editable taBind";
                };
                if (scope.$parent["updateTaBind" + (attrs.id || "")] = function() {
                    _isReadonly || ngModel.$setViewValue(_compileHtml());
                }, _isInputFriendly) if (_isContentEditable) {
                    if (element.on("cut", function(e) {
                        _isReadonly ? e.preventDefault() : $timeout(function() {
                            ngModel.$setViewValue(_compileHtml());
                        }, 0);
                    }), element.on("paste", function(e, eventData) {
                        eventData && angular.extend(e, eventData);
                        var text;
                        if (e.clipboardData || e.originalEvent && e.originalEvent.clipboardData ? text = (e.originalEvent || e).clipboardData.getData("text/plain") : $window.clipboardData && (text = $window.clipboardData.getData("Text")), 
                        !text && !_isReadonly) return !0;
                        if (e.preventDefault(), !_isReadonly) {
                            var _working = angular.element("<div></div>");
                            if (_working[0].innerHTML = text, text = _working.text(), document.selection) {
                                var range = document.selection.createRange();
                                range.pasteHTML(text);
                            } else document.execCommand("insertText", !1, text);
                            ngModel.$setViewValue(_compileHtml());
                        }
                    }), element.on("keyup", function() {
                        _isReadonly || ngModel.$setViewValue(_compileHtml());
                    }), element.on("blur", function() {
                        _focussed = !1;
                        var val = _compileHtml();
                        _isReadonly || ngModel.$setViewValue(val === _defaultVal ? "" : _compileHtml()), 
                        ngModel.$render();
                    }), attrs.placeholder) {
                        var ruleIndex;
                        if (!attrs.id) throw "textAngular Error: An unique ID is required for placeholders to work";
                        ruleIndex = addCSSRule("#" + attrs.id + ".placeholder-text:before", 'content: "' + attrs.placeholder + '"'), 
                        scope.$on("$destroy", function() {
                            removeCSSRule(ruleIndex);
                        });
                    }
                    element.on("focus", function() {
                        _focussed = !0, ngModel.$render();
                    });
                } else element.on("paste cut", function() {
                    _isReadonly || $timeout(function() {
                        ngModel.$setViewValue(_compileHtml());
                    }, 0);
                }), element.on("change blur", function() {
                    _isReadonly || ngModel.$setViewValue(_compileHtml());
                });
                var _sanitize = function(unsafe) {
                    return ngModel.$oldViewValue = taSanitize(taFixChrome(unsafe), ngModel.$oldViewValue);
                };
                ngModel.$parsers.push(_sanitize), ngModel.$formatters.push(_sanitize);
                var selectorClickHandler = function(event) {
                    return scope.$emit("ta-element-select", this), event.preventDefault(), !1;
                }, fileDropHandler = function(event, eventData) {
                    if (eventData && angular.extend(event, eventData), !dropFired && !_isReadonly) {
                        dropFired = !0;
                        var dataTransfer;
                        dataTransfer = event.originalEvent ? event.originalEvent.dataTransfer : event.dataTransfer, 
                        scope.$emit("ta-drop-event", this, event, dataTransfer), $timeout(function() {
                            dropFired = !1;
                        }, 100);
                    }
                };
                scope.$parent["reApplyOnSelectorHandlers" + (attrs.id || "")] = function() {
                    _isReadonly || angular.forEach(taSelectableElements, function(selector) {
                        element.find(selector).off("click", selectorClickHandler).on("click", selectorClickHandler);
                    });
                }, ngModel.$render = function() {
                    var val = ngModel.$viewValue || "";
                    document.activeElement !== element[0] ? _isContentEditable ? (attrs.placeholder ? "" === val ? (_focussed ? element.removeClass("placeholder-text") : element.addClass("placeholder-text"), 
                    element[0].innerHTML = _defaultVal) : (element.removeClass("placeholder-text"), 
                    element[0].innerHTML = val) : element[0].innerHTML = "" === val ? _defaultVal : val, 
                    _isReadonly ? element.off("drop", fileDropHandler) : (angular.forEach(taSelectableElements, function(selector) {
                        element.find(selector).on("click", selectorClickHandler);
                    }), element.on("drop", fileDropHandler))) : "textarea" !== element[0].tagName.toLowerCase() && "input" !== element[0].tagName.toLowerCase() ? element[0].innerHTML = taApplyCustomRenderers(val) : element.val(val) : _isContentEditable && element.removeClass("placeholder-text");
                }, attrs.taReadonly && (_isReadonly = scope.$parent.$eval(attrs.taReadonly), _isReadonly ? (("textarea" === element[0].tagName.toLowerCase() || "input" === element[0].tagName.toLowerCase()) && element.attr("disabled", "disabled"), 
                void 0 !== element.attr("contenteditable") && element.attr("contenteditable") && element.removeAttr("contenteditable")) : "textarea" === element[0].tagName.toLowerCase() || "input" === element[0].tagName.toLowerCase() ? element.removeAttr("disabled") : _isContentEditable && element.attr("contenteditable", "true"), 
                scope.$parent.$watch(attrs.taReadonly, function(newVal, oldVal) {
                    oldVal !== newVal && (newVal ? (("textarea" === element[0].tagName.toLowerCase() || "input" === element[0].tagName.toLowerCase()) && element.attr("disabled", "disabled"), 
                    void 0 !== element.attr("contenteditable") && element.attr("contenteditable") && element.removeAttr("contenteditable"), 
                    angular.forEach(taSelectableElements, function(selector) {
                        element.find(selector).on("click", selectorClickHandler);
                    }), element.off("drop", fileDropHandler)) : ("textarea" === element[0].tagName.toLowerCase() || "input" === element[0].tagName.toLowerCase() ? element.removeAttr("disabled") : _isContentEditable && element.attr("contenteditable", "true"), 
                    angular.forEach(taSelectableElements, function(selector) {
                        element.find(selector).off("click", selectorClickHandler);
                    }), element.on("drop", fileDropHandler)), _isReadonly = newVal);
                })), _isContentEditable && !_isReadonly && (angular.forEach(taSelectableElements, function(selector) {
                    element.find(selector).on("click", selectorClickHandler);
                }), element.on("drop", fileDropHandler));
            }
        };
    } ]).factory("taApplyCustomRenderers", [ "taCustomRenderers", function(taCustomRenderers) {
        return function(val) {
            var element = angular.element("<div></div>");
            return element[0].innerHTML = val, angular.forEach(taCustomRenderers, function(renderer) {
                var elements = [];
                renderer.selector && "" !== renderer.selector ? elements = element.find(renderer.selector) : renderer.customAttribute && "" !== renderer.customAttribute && (elements = getByAttribute(element, renderer.customAttribute)), 
                angular.forEach(elements, function(_element) {
                    _element = angular.element(_element), renderer.selector && "" !== renderer.selector && renderer.customAttribute && "" !== renderer.customAttribute ? void 0 !== _element.attr(renderer.customAttribute) && renderer.renderLogic(_element) : renderer.renderLogic(_element);
                });
            }), element[0].innerHTML;
        };
    } ]).directive("taMaxText", function() {
        return {
            restrict: "A",
            require: "ngModel",
            link: function(scope, elem, attrs, ctrl) {
                function validator(viewValue) {
                    var source = angular.element("<div/>");
                    source.html(viewValue);
                    var length = source.text().length;
                    return max >= length ? (ctrl.$setValidity("taMaxText", !0), viewValue) : void ctrl.$setValidity("taMaxText", !1);
                }
                var max = parseInt(scope.$eval(attrs.taMaxText));
                if (isNaN(max)) throw "Max text must be an integer";
                attrs.$observe("taMaxText", function(value) {
                    if (max = parseInt(value), isNaN(max)) throw "Max text must be an integer";
                    ctrl.$dirty && ctrl.$setViewValue(ctrl.$viewValue);
                }), ctrl.$parsers.unshift(validator);
            }
        };
    }).factory("taFixChrome", function() {
        var taFixChrome = function(html) {
            for (var $html = angular.element("<div>" + html + "</div>"), spans = angular.element($html).find("span"), s = 0; s < spans.length; s++) {
                var span = angular.element(spans[s]);
                span.attr("style") && span.attr("style").match(/line-height: 1.428571429;|color: inherit; line-height: 1.1;/i) && (span.attr("style", span.attr("style").replace(/( |)font-family: inherit;|( |)line-height: 1.428571429;|( |)line-height:1.1;|( |)color: inherit;/gi, "")), 
                span.attr("style") && "" !== span.attr("style") || (span.next().length > 0 && "BR" === span.next()[0].tagName && span.next().remove(), 
                span.replaceWith(span[0].innerHTML)));
            }
            var result = $html[0].innerHTML.replace(/style="[^"]*?(line-height: 1.428571429;|color: inherit; line-height: 1.1;)[^"]*"/gi, "");
            return result !== $html[0].innerHTML && ($html[0].innerHTML = result), $html[0].innerHTML;
        };
        return taFixChrome;
    }).factory("taSanitize", [ "$sanitize", function($sanitize) {
        return function(unsafe, oldsafe) {
            var unsafeElement = angular.element("<div>" + unsafe + "</div>");
            angular.forEach(getByAttribute(unsafeElement, "align"), function(element) {
                element.css("text-align", element.attr("align")), element.removeAttr("align");
            }), unsafe = unsafeElement[0].innerHTML;
            var safe;
            try {
                safe = $sanitize(unsafe);
            } catch (e) {
                safe = oldsafe || "";
            }
            return safe;
        };
    } ]).directive("textAngularToolbar", [ "$compile", "textAngularManager", "taOptions", "taTools", "taToolExecuteAction", "$window", function($compile, textAngularManager, taOptions, taTools, taToolExecuteAction, $window) {
        return {
            scope: {
                name: "@"
            },
            restrict: "EA",
            link: function(scope, element, attrs) {
                if (!scope.name || "" === scope.name) throw "textAngular Error: A toolbar requires a name";
                var isTouchSupported = "ontouchstart" in window;
                if (isTouchSupported) return {};
                angular.extend(scope, angular.copy(taOptions)), attrs.taToolbar && (scope.toolbar = scope.$parent.$eval(attrs.taToolbar)), 
                attrs.taToolbarClass && (scope.classes.toolbar = attrs.taToolbarClass), attrs.taToolbarGroupClass && (scope.classes.toolbarGroup = attrs.taToolbarGroupClass), 
                attrs.taToolbarButtonClass && (scope.classes.toolbarButton = attrs.taToolbarButtonClass), 
                attrs.taToolbarActiveButtonClass && (scope.classes.toolbarButtonActive = attrs.taToolbarActiveButtonClass), 
                attrs.taFocussedClass && (scope.classes.focussed = attrs.taFocussedClass), scope.disabled = !0, 
                scope.focussed = !1, scope._$element = element, element[0].innerHTML = "", element.addClass("ta-toolbar " + scope.classes.toolbar), 
                scope.$watch("focussed", function() {
                    scope.focussed ? element.addClass(scope.classes.focussed) : element.removeClass(scope.classes.focussed);
                });
                var setupToolElement = function(toolDefinition, toolScope) {
                    var toolElement;
                    if (toolElement = angular.element(toolDefinition && toolDefinition.display ? toolDefinition.display : "<button type='button'>"), 
                    toolElement.addClass(scope.classes.toolbarButton), toolElement.attr("name", toolScope.name), 
                    toolElement.attr("unselectable", "on"), toolElement.attr("ng-disabled", "isDisabled()"), 
                    toolElement.attr("tabindex", "-1"), toolElement.attr("ng-click", "executeAction()"), 
                    toolElement.attr("ng-class", "displayActiveToolClass(active)"), toolElement.on(startEvent, function(e, eventData) {
                        return eventData && angular.extend(e, eventData), e.preventDefault(), !1;
                    }), toolDefinition && !toolDefinition.display && !toolScope._display && (toolElement[0].innerHTML = "", 
                    toolDefinition.buttontext && (toolElement[0].innerHTML = toolDefinition.buttontext), 
                    toolDefinition.iconclass)) {
                        var icon = angular.element("<i>"), content = toolElement[0].innerHTML;
                        icon.addClass(toolDefinition.iconclass), toolElement[0].innerHTML = "", toolElement.append(icon), 
                        content && "" !== content && toolElement.append("&nbsp;" + content);
                    }
                    return toolScope._lastToolDefinition = angular.copy(toolDefinition), $compile(toolElement)(toolScope);
                };
                scope.tools = {}, scope._parent = {
                    disabled: !0,
                    showHtml: !1,
                    queryFormatBlockState: function() {
                        return !1;
                    }
                };
                var defaultChildScope = {
                    $window: $window,
                    $editor: function() {
                        return scope._parent;
                    },
                    isDisabled: function() {
                        return this.$eval("disabled") || this.$eval("disabled()") || "html" !== this.name && this.$editor().showHtml || this.$parent.disabled || this.$editor().disabled;
                    },
                    displayActiveToolClass: function(active) {
                        return active ? scope.classes.toolbarButtonActive : "";
                    },
                    executeAction: taToolExecuteAction
                };
                angular.forEach(scope.toolbar, function(group) {
                    var groupElement = angular.element("<div>");
                    groupElement.addClass(scope.classes.toolbarGroup), angular.forEach(group, function(tool) {
                        scope.tools[tool] = angular.extend(scope.$new(!0), taTools[tool], defaultChildScope, {
                            name: tool
                        }), scope.tools[tool].$element = setupToolElement(taTools[tool], scope.tools[tool]), 
                        groupElement.append(scope.tools[tool].$element);
                    }), element.append(groupElement);
                }), scope.updateToolDisplay = function(key, _newTool, forceNew) {
                    var toolInstance = scope.tools[key];
                    if (toolInstance) {
                        if (toolInstance._lastToolDefinition && !forceNew && (_newTool = angular.extend({}, toolInstance._lastToolDefinition, _newTool)), 
                        null === _newTool.buttontext && null === _newTool.iconclass && null === _newTool.display) throw 'textAngular Error: Tool Definition for updating "' + key + '" does not have a valid display/iconclass/buttontext value';
                        null === _newTool.buttontext && delete _newTool.buttontext, null === _newTool.iconclass && delete _newTool.iconclass, 
                        null === _newTool.display && delete _newTool.display;
                        var toolElement = setupToolElement(_newTool, toolInstance);
                        toolInstance.$element.replaceWith(toolElement), toolInstance.$element = toolElement;
                    }
                }, scope.addTool = function(key, _newTool, groupIndex, index) {
                    scope.tools[key] = angular.extend(scope.$new(!0), taTools[key], defaultChildScope, {
                        name: key
                    }), scope.tools[key].$element = setupToolElement(taTools[key], scope.tools[key]);
                    var group;
                    void 0 === groupIndex && (groupIndex = scope.toolbar.length - 1), group = angular.element(element.children()[groupIndex]), 
                    void 0 === index ? (group.append(scope.tools[key].$element), scope.toolbar[groupIndex][scope.toolbar[groupIndex].length - 1] = key) : (group.children().eq(index).after(scope.tools[key].$element), 
                    scope.toolbar[groupIndex][index] = key);
                }, textAngularManager.registerToolbar(scope), scope.$on("$destroy", function() {
                    textAngularManager.unregisterToolbar(scope.name);
                });
            }
        };
    } ]).service("taToolExecuteAction", [ "$q", function($q) {
        return function(editor) {
            void 0 !== editor && (this.$editor = function() {
                return editor;
            });
            var deferred = $q.defer(), promise = deferred.promise, _editor = this.$editor();
            promise["finally"](function() {
                _editor.endAction.call(_editor);
            });
            var result;
            try {
                result = this.action(deferred, _editor.startAction());
            } catch (any) {}
            (result || void 0 === result) && deferred.resolve();
        };
    } ]).service("textAngularManager", [ "taToolExecuteAction", "taTools", "taRegisterTool", function(taToolExecuteAction, taTools, taRegisterTool) {
        var toolbars = {}, editors = {};
        return {
            registerEditor: function(name, scope, targetToolbars) {
                if (!name || "" === name) throw "textAngular Error: An editor requires a name";
                if (!scope) throw "textAngular Error: An editor requires a scope";
                if (editors[name]) throw 'textAngular Error: An Editor with name "' + name + '" already exists';
                var _toolbars = [];
                return angular.forEach(targetToolbars, function(_name) {
                    toolbars[_name] && _toolbars.push(toolbars[_name]);
                }), editors[name] = {
                    scope: scope,
                    toolbars: targetToolbars,
                    _registerToolbar: function(toolbarScope) {
                        this.toolbars.indexOf(toolbarScope.name) >= 0 && _toolbars.push(toolbarScope);
                    },
                    editorFunctions: {
                        disable: function() {
                            angular.forEach(_toolbars, function(toolbarScope) {
                                toolbarScope.disabled = !0;
                            });
                        },
                        enable: function() {
                            angular.forEach(_toolbars, function(toolbarScope) {
                                toolbarScope.disabled = !1;
                            });
                        },
                        focus: function() {
                            angular.forEach(_toolbars, function(toolbarScope) {
                                toolbarScope._parent = scope, toolbarScope.disabled = !1, toolbarScope.focussed = !0;
                            });
                        },
                        unfocus: function() {
                            angular.forEach(_toolbars, function(toolbarScope) {
                                toolbarScope.disabled = !0, toolbarScope.focussed = !1;
                            });
                        },
                        updateSelectedStyles: function(rangyRange) {
                            angular.forEach(_toolbars, function(toolbarScope) {
                                angular.forEach(toolbarScope.tools, function(toolScope) {
                                    toolScope.activeState && (toolScope.active = toolScope.activeState(rangyRange));
                                });
                            });
                        },
                        sendKeyCommand: function(event) {
                            var result = !1;
                            return (event.ctrlKey || event.metaKey) && angular.forEach(taTools, function(tool, name) {
                                if (tool.commandKeyCode && tool.commandKeyCode === event.which) for (var _t = 0; _t < _toolbars.length; _t++) if (void 0 !== _toolbars[_t].tools[name]) {
                                    taToolExecuteAction.call(_toolbars[_t].tools[name], scope), result = !0;
                                    break;
                                }
                            }), result;
                        },
                        triggerElementSelect: function(event, element) {
                            var elementHasAttrs = function(_element, attrs) {
                                for (var result = !0, i = 0; i < attrs.length; i++) result = result && _element.attr(attrs[i]);
                                return result;
                            }, workerTools = [], unfilteredTools = {}, result = !1;
                            element = angular.element(element);
                            var onlyWithAttrsFilter = !1;
                            if (angular.forEach(taTools, function(tool, name) {
                                tool.onElementSelect && tool.onElementSelect.element && tool.onElementSelect.element.toLowerCase() === element[0].tagName.toLowerCase() && (!tool.onElementSelect.filter || tool.onElementSelect.filter(element)) && (onlyWithAttrsFilter = onlyWithAttrsFilter || angular.isArray(tool.onElementSelect.onlyWithAttrs) && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs), 
                                (!tool.onElementSelect.onlyWithAttrs || elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs)) && (unfilteredTools[name] = tool));
                            }), onlyWithAttrsFilter ? (angular.forEach(unfilteredTools, function(tool, name) {
                                tool.onElementSelect.onlyWithAttrs && elementHasAttrs(element, tool.onElementSelect.onlyWithAttrs) && workerTools.push({
                                    name: name,
                                    tool: tool
                                });
                            }), workerTools.sort(function(a, b) {
                                return b.tool.onElementSelect.onlyWithAttrs.length - a.tool.onElementSelect.onlyWithAttrs.length;
                            })) : angular.forEach(unfilteredTools, function(tool, name) {
                                workerTools.push({
                                    name: name,
                                    tool: tool
                                });
                            }), workerTools.length > 0) for (var tool = workerTools[0].tool, name = workerTools[0].name, _t = 0; _t < _toolbars.length; _t++) if (void 0 !== _toolbars[_t].tools[name]) {
                                tool.onElementSelect.action.call(_toolbars[_t].tools[name], event, element, scope), 
                                result = !0;
                                break;
                            }
                            return result;
                        }
                    }
                }, editors[name].editorFunctions;
            },
            retrieveEditor: function(name) {
                return editors[name];
            },
            unregisterEditor: function(name) {
                delete editors[name];
            },
            registerToolbar: function(scope) {
                if (!scope) throw "textAngular Error: A toolbar requires a scope";
                if (!scope.name || "" === scope.name) throw "textAngular Error: A toolbar requires a name";
                if (toolbars[scope.name]) throw 'textAngular Error: A toolbar with name "' + scope.name + '" already exists';
                toolbars[scope.name] = scope, angular.forEach(editors, function(_editor) {
                    _editor._registerToolbar(scope);
                });
            },
            retrieveToolbar: function(name) {
                return toolbars[name];
            },
            retrieveToolbarsViaEditor: function(name) {
                var result = [], _this = this;
                return angular.forEach(this.retrieveEditor(name).toolbars, function(name) {
                    result.push(_this.retrieveToolbar(name));
                }), result;
            },
            unregisterToolbar: function(name) {
                delete toolbars[name];
            },
            updateToolsDisplay: function(newTaTools) {
                var _this = this;
                angular.forEach(newTaTools, function(_newTool, key) {
                    _this.updateToolDisplay(key, _newTool);
                });
            },
            resetToolsDisplay: function() {
                var _this = this;
                angular.forEach(taTools, function(_newTool, key) {
                    _this.resetToolDisplay(key);
                });
            },
            updateToolDisplay: function(toolKey, _newTool) {
                var _this = this;
                angular.forEach(toolbars, function(toolbarScope, toolbarKey) {
                    _this.updateToolbarToolDisplay(toolbarKey, toolKey, _newTool);
                });
            },
            resetToolDisplay: function(toolKey) {
                var _this = this;
                angular.forEach(toolbars, function(toolbarScope, toolbarKey) {
                    _this.resetToolbarToolDisplay(toolbarKey, toolKey);
                });
            },
            updateToolbarToolDisplay: function(toolbarKey, toolKey, _newTool) {
                if (!toolbars[toolbarKey]) throw 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists';
                toolbars[toolbarKey].updateToolDisplay(toolKey, _newTool);
            },
            resetToolbarToolDisplay: function(toolbarKey, toolKey) {
                if (!toolbars[toolbarKey]) throw 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists';
                toolbars[toolbarKey].updateToolDisplay(toolKey, taTools[toolKey], !0);
            },
            removeTool: function(toolKey) {
                delete taTools[toolKey], angular.forEach(toolbars, function(toolbarScope) {
                    delete toolbarScope.tools[toolKey];
                    for (var i = 0; i < toolbarScope.toolbar.length; i++) {
                        for (var toolbarIndex, j = 0; j < toolbarScope.toolbar[i].length; j++) {
                            if (toolbarScope.toolbar[i][j] === toolKey) {
                                toolbarIndex = {
                                    group: i,
                                    index: j
                                };
                                break;
                            }
                            if (void 0 !== toolbarIndex) break;
                        }
                        void 0 !== toolbarIndex && (toolbarScope.toolbar[toolbarIndex.group].slice(toolbarIndex.index, 1), 
                        toolbarScope._$element.children().eq(toolbarIndex.group).children().eq(toolbarIndex.index).remove());
                    }
                });
            },
            addTool: function(toolKey, toolDefinition, group, index) {
                taRegisterTool(toolKey, toolDefinition), angular.forEach(toolbars, function(toolbarScope) {
                    toolbarScope.addTool(toolKey, toolDefinition, group, index);
                });
            },
            addToolToToolbar: function(toolKey, toolDefinition, toolbarKey, group, index) {
                taRegisterTool(toolKey, toolDefinition), toolbars[toolbarKey].addTool(toolKey, toolDefinition, group, index);
            },
            refreshEditor: function(name) {
                if (!editors[name]) throw 'textAngular Error: No Editor with name "' + name + '" exists';
                editors[name].scope.updateTaBindtaTextElement(), editors[name].scope.$$phase || editors[name].scope.$digest();
            }
        };
    } ]);
}();